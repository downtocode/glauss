/*
 * This file is part of physengine.
 * Copyright (c) 2013 Rostislav Pehlivanov <atomnuker@gmail.com>
 *
 * physengine is free software: you can redistribute it and/or modify *
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * physengine is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with physengine.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include "config.h"
#include "options.h"
#include "physics/physics.h"
#include "output.h"
#include "msg_phys.h"
#include "physics/physics_aux.h"

int out_write_xyz(phys_obj *object, const char *template_str,
                pthread_spinlock_t *io_halt)
{
    if(io_halt)
        pthread_spin_lock(io_halt);

    char filetodump[120];
    snprintf(filetodump, sizeof(filetodump), template_str, phys_stats->progress);
    /* Check if file exist */
    if(!access(filetodump, R_OK))
        return 1;
    FILE *out = fopen(filetodump, "w");
    pprintf(PRI_ESSENTIAL, "Created %s\n", filetodump);
    fprintf(out, "%u\n", option->obj);
    fprintf(out, "#Generated by %s\n", PACKAGE_STRING);
    for(unsigned int i = 0; i < option->obj; i++) {
        fprintf(out, "%s %f %f %f\n", atom_prop[object[i].atomnumber].name,\
                (float)object[i].pos[0], (float)object[i].pos[1],\
                (float)object[i].pos[2]);
    }
    fclose(out);

    if(io_halt)
        pthread_spin_unlock(io_halt);

    return 0;
}

size_t out_write_array(phys_obj *object, const char *template_str,
                    pthread_spinlock_t *io_halt)
{
    if(io_halt)
        pthread_spin_lock(io_halt);

    char filetodump[120];
    snprintf(filetodump, sizeof(filetodump), template_str, phys_stats->progress);
    /* Check if file exist */
    if(!access(filetodump, R_OK))
        return 1;

    FILE *out = fopen(filetodump, "wb");

    size_t written = fwrite(object, sizeof(phys_obj), option->obj, out);

    pprint("Wrote %lu bytes to %s\n", written*sizeof(phys_obj), filetodump);

    fclose(out);
    if(io_halt)
        pthread_spin_unlock(io_halt);

    return written;
}

size_t in_write_array(phys_obj **object, const char *filename,
                    pthread_spinlock_t *io_halt)
{
    if(io_halt)
        pthread_spin_lock(io_halt);

    int fd = -1;
    struct stat s;
    if ((fd = open(filename, O_RDONLY, 0)) == -1)
        pprint_err("Could not open %s!\n", filename);

    if (fstat(fd, &s) < 0) {
        pprint_err("Could not get filesize!\n");
    }

    phys_obj *obj_e = mmap(NULL, s.st_size, PROT_READ, MAP_PRIVATE, fd, 0);

    memcpy((*object), obj_e, s.st_size);

    munmap(obj_e, s.st_size);

    close(fd);

    if(io_halt)
        pthread_spin_unlock(io_halt);

    return s.st_size;
}
